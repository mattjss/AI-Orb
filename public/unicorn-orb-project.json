{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.1,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform float uTime;\nuniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0.12549019607843137, 0.023529411764705882, 0.23137254901960785);\ncase 1: return vec3(0.4666666666666667, 0.09019607843137255, 0.40784313725490196);\ncase 2: return vec3(0.40784313725490196, 0.6470588235294118, 0.9294117647058824);\ncase 3: return vec3(0, 0.1843137254901961, 0.8392156862745098);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}float getStop(int index) {\nswitch(index) {\ncase 0: return 0.0000;\ncase 1: return 0.3333;\ncase 2: return 0.6667;\ncase 3: return 1.0000;\ncase 4: return 0.0000;\ncase 5: return 0.0000;\ncase 6: return 0.0000;\ncase 7: return 0.0000;\ncase 8: return 0.0000;\ncase 9: return 0.0000;\ncase 10: return 0.0000;\ncase 11: return 0.0000;\ncase 12: return 0.0000;\ncase 13: return 0.0000;\ncase 14: return 0.0000;\ncase 15: return 0.0000;\ndefault: return 0.0;\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}vec3 linear_from_srgb(vec3 rgb) {\nreturn pow(max(rgb, vec3(0.0)), vec3(2.2));\n}vec3 srgb_from_linear(vec3 lin) {\nreturn pow(max(lin, vec3(0.0)), vec3(1.0/2.2));\n}vec3 safeCbrt(vec3 v) {\nreturn sign(v) * pow(abs(v), vec3(1.0/3.0));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) {\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);\nvec3 lms1 = safeCbrt( kCONEtoLMS*lin1 );\nvec3 lms2 = safeCbrt( kCONEtoLMS*lin2 );\nvec3 lms = mix( lms1, lms2, a );\nlms *= 1.0 + 0.025 * a * (1.0-a);\nreturn kLMStoCONE * (lms * lms * lms);\n}vec3 getGradientColor(float position) {\nposition = clamp(position, 0.0, 1.0);\nif (4 <= 1) return getColor(0);for (int i = 0; i < 15; i++) {\nif (i >= 4 - 1) break;\nfloat stopA = getStop(i);\nfloat stopB = getStop(i + 1);\nif (position <= stopB || i == 4 - 2) {\nfloat denom = max(stopB - stopA, 0.00001);\nfloat t = clamp((position - stopA) / denom, 0.0, 1.0);\nvec3 linA = linear_from_srgb(getColor(i));\nvec3 linB = linear_from_srgb(getColor(i + 1));\nvec3 mixed = oklab_mix(linA, linB, t);\nreturn srgb_from_linear(mixed);\n}\n}\nreturn getColor(min(4 - 1, 15));\n}out vec4 fragColor;vec3 applyColorToPosition(float position) {\nvec3 color = vec3(0);\nposition -= (uTime * 0.01 + 0.0000);\nfloat cycle = floor(position);\nbool reverse = 1.0000 > 0.5 && int(cycle) % 2 == 0;\nfloat animatedPos = reverse ? 1.0 - fract(position) : fract(position);color = getGradientColor(animatedPos);\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor += dither;\nreturn color;\n}vec3 linearGrad(vec2 uv) {\nfloat position = (uv.x+0.5);\nreturn applyColorToPosition(position);\n}vec3 getGradient(vec2 uv) {\nreturn linearGrad(uv);\n}vec3 getBgColor(vec2 uv) {return getGradient(uv);return vec3(0.12549019607843137, 0.023529411764705882, 0.23137254901960785);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= max(0.0920*2., 1e-5);\nuv = rotate(uv, (0.0783 - 0.5) * 2. * PI);\nvec4 color = vec4(getBgColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":true},"id":"gradient"}],"options":{"name":"AI Orb 1","fps":120,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":true,"freePlan":false},"version":"2.0.5","id":"1pR6h5M1hBZZGegkYa8W"}
